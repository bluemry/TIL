# 시작하기 - 버전관리

# 목차
 - [Git 기초 개념](#git-기초-개념--핵심은-스냅샷인거같아)
   - [배경 : 버전관리란(VCS)](#배경--버전-관리란-vcsversion-control-system)
   - [스냅샷](#기록방식--스냅샷)
   - [세가지 상태](#세가지-상태--committed-modified-staged)
   - [기록방식 - object : 스냅샷 방식과 상응](#깃은-모든-데이터를-오브젝트로-저장)

 - [Git 설정](#git-설정)

 - [Git 기초](#git-실행)
  - [Git 저장소 만들기](#git-저장소-만들기)

---

# Git 기초 개념 : 핵심은 스냅샷인거같아.

## 배경 : 버전 관리란? VCS(Version Control System)

- 각 파일 / 프로젝트를 이전 상태로 돌리기
- 버전별 수정 내용 비교
- 누가 언제 만들어낸 이슈 확인 가능.
- 복구.

### 버전 관리 종류

- 로컬 VCS : 간단한 데이터베이스를 통해, `파일의 변경정보 관리`

- 중앙집중식 VCS(CVCS) : 다른 개발자들과 함께 작업하는 경우.

  - 서버를 별도로 두고, 클라가 중앙 서버에서 파일을 받아서 사용.

  #### **_`> 로컬 VCS, CVCS문제`_**

  : 중앙 데이터베이스나, 하드에 문제 발생시 다 잃는.

- 분산 버전 관리 시스템 (DVCS)
  : 저장소를 `히스토리와 더불어 전부 복제`
  <br>

# 요약

- 기존은, 파일이 변경되는 시점을 기준으로, 다양한 버전의 파일들을 데이터베이스에 기록

- 필요한 경우, 해당 버전의 파일을 받아서 사용함

- 이런 경우, DB가 날라가면 ㅈ됨.

- 따라서, DB에서 파일만 받아오는게 아니라, 히스토리와 더불어 전부 받아옴.

  - 그러므로 VCS, CVCS에 비해서는 당연히 용량이 크겠지.
    - 그걸 git에서는 스냅샷 스트림 방식으로.. 완화

## 기록방식 : 스냅샷

  > : 파일전체와 히스토리 전부를.. 기록 및 불러옴.<br><br>다만, 매번 파일 전체를 저장하는 건 아니고, 변경된 부분이 없는 파일은 레퍼런스를 저장.<br>

      델타 VCS와의 차이
        - 델타는 변경된 부분만 저장하는데, 이 경우 최신버전을 불러오려면, 최초 버전 + 변경된 부분 + 변경된 부분 +... 최신 변경된 부분 이런식으로 다 불러와야한다.

[참고링크](https://tech.10000lab.xyz/git/how-git-is-different.html)

- DVCS > 거의 모든 명령을 로컬에서 실행

      스냅샷 형식으로 로컬에서도 모든 히스토리와 데이터를 다 갖고 있으니, 로컬에서 하는 것이 문제가 안됨.

- git은 데이터를 '추가'할 뿐.

      커밋만 한 후라면, 데이터를 잃을 일은 거의없다.

## 세가지 상태 : Committed, Modified, Staged.

  - Modified : 수정한 파일을 아직 커밋하지 않은 상태.<br>
    (가장 주의해야할 상태)

  - Staged : 수정한 파일을 커밋할 거라고 표시한 상태

  - Committed : 데이터가 로컬 데이터베이스(.git 폴더)에 안전하게 저장된 상태.

## 깃은 모든 데이터를 오브젝트로 저장.
  (중복되지 않는 해시로. SHA-1 알고리즘으로 생성)
  - 오브젝트 타입에는 4가지
    - blob(브롭) : 실제 파일 내용을 압축하고 저장한 것.
    - 트리(tree) : 디렉토리
    - 커밋(commit) : 가장 많은 정보.(.git/refs)
    - 태그 : 다른 오브젝트에 이름 붙여주는

## 그 외
  - 깃은 브랜치 생성과 머지가 자유롭다.

  - 브랜치는 단순히 스냅샷을 가르키는 레퍼런스이기 때문.

### 요약.

git은 일종의 VCS로, 그중에서도 DVCS에 해당.
특히나 git은 스냅샷 방식으로 버전 관리를 하는데, 여기서 스냅샷이란 해당 버전 파일뿐만 아니라 히스토리까지 통으로 저장하는 방식. (이는 델타vcs랑 비교하면 훨씬 효율적임을 알 수 있음)

git에는 네가지 오브젝트가 있는데 그중에서도 파일을 압축하고 저장하는 blob, 디렉토리를 저장하는 tree, 그리고 commit이 있음.
이를 git의 스냅샷 방식에 대입해보면

- blob : 파일들을 압축하고 저장하는 것
- tree : 해당 파일들의 일종의 메타데이터에 해당되는.. 전체적인 구조, 이름 등을 저장한 것
- commit : 히스토리에 해당되는 것

이라고 볼 수 있겠다.

그 외에도 3가지 상태(modified, staged, commited) 및 브랜치 이해

## Git 설정
  ### 3가지 설정파일
  - `/etc/gitconfig`(최상위 경로니까) : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정
    - `git config --system`으로 읽고 쓸 수 있음.
  - `~/.gitconfig` (사용자 경로니까) : 사용자에게만 적용되는 설정
    - `git config --global`으로 : 가령 처음 git 설치하고 이메일, 이름 설정할때.
  - `프로젝트 폴더/.git/config`(프로젝트 경로니까) : 해당 프로젝트에 적용되는 설정.
    - `git config --local`으로
  ### 사용자 정보
  - `git config --global user.name`
  - `git config --global user.email`

  ### 편집기
  - `git config --global core.editor [텍스트 편집프로그램]`
  ### 설정 확인
  - `git config --list`

---
## Git 기초

### Git 저장소 만들기
두가지 방법이 있다. `init`과 `clone`
- init은 기존에 버전관리가 안되고 있었던 폴더에 사용하는 것이다.   
터미널에서`git init` 명령어를 치면 실행되며, .git 디렉토리가 생긴다.   
이때는 아직 버전관리가 되지 않는 상태. commit이 한번 되기 시작하면 그때 버전관리가 시작된다.

- clone은 서버에서 저장소를 복사하는 것.   
물론, git의 방식의로 모든 데이터와 히스토리 다.(물론 서버에서 했던 설정같은건 빼고)   
`git clone <url>`을 통해 실행된다.

### 추적하기
  - 새로 추가된 파일, 즉 기존에 커밋된적이 없던 파일은 untracked 상태이다.
  - track 상태로 만드려면 `git add <해당파일>`
  - 이미 tracked 상태라도, modified 된걸 staged하려면 `git add <해당 파일>`
  - staged 상태면 커밋대상에 포함됨.
  - 반대로 staged 상태에서 제외하려면

  - 이런 상태를 확인하기 위해서는 `git status`
    - 다만, 너무 내용이 많아보이면 `git status -s`(short를 의미한다.)
      - 해당명령어로는 `<상태><상태> 파일명`으로 나타난다.
      - Untracked 상태면 `??`, Modified `M`, Add `A`

## 파일 무시하기(.gitignore)

## Staged와 Unstaged 상태의 변경 내용 보기 : diff

## Staging Area 생략도 가능. git commit -a

## git rm > 그냥 삭제하면 단순히 unstaged 상태일 뿐이다. 
  - untracked 상태로 만드려면 `git rm --cached`

## 파일 이름 변경 : git은 파일 이름은 관리x
  - 따라서 이름을 바꿀경우 `git mv file_from file_to`
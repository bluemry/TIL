목차
https://developer.chrome.com/blog/inside-browser-part1?hl=ko

- 해볼것
  - [작업자]('https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing_workers')
  - [캔버스]('https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_building_practice')
  - [WebGL]('https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL')

- JS
 	- 언어로서 JS : 스크립트 언어
    	- 싱글스레드 : 힙, 콜스택, 태스크 큐, 이벤트 루프, 웹 API(브라우저)
        - 실행 단계 : 파싱, AST, 호이스팅, 코드 실행, 실행단계(평가), 코드 실행 및 메모리 관리
        - 동적 언어 (메모리 등)
        - 스코프, 렉시컬 환경, 클로저, 호이스팅
        - window 객체 - this
        - 객체지향 - 프로토타입
        - var, let, const
    - 실행환경과 JS
    	- 브라우저 : window 객체와 this / 브라우저 API
        - Node 등 : 모듈

    - API

    - SSR, CSR : 어디서 HTML을 생성하냐.

- 프로그래밍 언어로 JS지식들 (객체지향)
  - 데이터과 연산 (객체지향언어답게, 모든 자료형에 프로토타입 객체가 - 원시도 래퍼객체)   
  즉 가장 작은 단위이자 줄기는 : `데이터`와 `연산자`   
    - 데이터의 여러타입들.
    - 연산 방식 (연산자 /(어쩌면 기초적 알고리즘에 해당하는) 반복문, 제어문, 함수)
    - 각 자료형에 맞는 `프로토타입 객체`와 `메서드`
      - `객체지향언어`, 즉 객체들의 집합으로 프로그램을 짜는

  - 프로토타입
    - 생성자 함수 (함수도 객체다..)
  - 동적타입언어
  - 클로저 :  - 캡슐화
  - 비동기 프로그래밍
  - 이벤트 루프 : 브라우저 환경
  - 호이스팅
  - 메모리 관리

  - 비고(js 작동방식에 관한 것들)
    - 클로저
    - 프로토타입과 프로토타입 기반 상속
    - 이벤트 루프
    - 실행 컨텍스트와 스코프.
    - let과 const
    - 모듈시스템



- 클라이언트 사이드 JS : `스크립트 언어`로서, API를 통해 브라우저를 제어, HTML에 동적
  - API
    - 브라우저
      - 비동기도 여기 포함되는..
    - 서드파티
  - JSON
  - 비고
    - 프레임워크
    왜 프레임워크를 사용해야 하나요? 그들이 어떤 문제를 해결하나요?
프레임워크를 선택할 때 어떤 질문을 해야 하나요? 프레임워크를 사용해야 하나요?
프레임워크에는 어떤 기능이 있나요? 그것들은 일반적으로 어떻게 작동하고, 이러한 기능에 대한 프레임워크에 구현은 어떻게 다른가요?
"vanilla" JavaScript 또는 HTML과 어떤 관련이 있나요?

- 서버 사이드 JS

---
모자란 부분
  - 프로토타입 기반 언어 : 실용은 ㅇㄷ?
    - 개념 : 그냥, 그 객체종이 공유하는 {특성 집합} === prototype / __proto__는 가리키는 속성
      - 예시 1) 아담과 사람
        - 아담은 사람의 프로토타입이다. (사람.prototype === 아담이 가진 특성 집합)
        - 모든 사람이 공유하는 속성은 아담에게 있다.
        - 사람.__proto__ ==> 아담

      - 예시 2)
        - A객체.prototype은 
          - 그냥 A객체와 A객체종들이 공유하는 속성 모음 (객체)
          - __proto__는 A객체.prototype를 get/set 할 수 있는 속성.
          - prototype 관계는 어디까지나 `생성자 함수`


      - 예시 3)
      ```javascript
      // 실제 코드가 이렇다는게 아니라 개념적 예시

      func {
        a : 1,
        b : 2,
        prototype : {
          constructor : ()=>{},
          A : 1
        }      }

      // obj2는 obj1을 상속했다는 가정

      obj2 {
        a : 3,
        b : 1,
        c : 4
      }ß

      ```
---
> 요약

---
# JS 깊은 개념과 이해를 위한 여러가지들.. 

## 프로그래밍 패러다임. (cf, 프로그래밍 패턴 - 디자인 패턴)
- `프로그램`을 작성하는데 사용되는 `기본적인 철학 또는 접근 방법`.
- 더 풀어쓰면,
  - `프로그램`이란, `컴퓨터`에게 주어지는 특정 작업을 지시하는 `명령문의 집합체`
  - `프로그래밍`이란, 단순히 일련의 명령문을 작성하는 것 이상으로, 문제해결을 위한 전체적인 과정
  - `컴퓨터`란, `명령어를 수행하는 기계`.
  - `명령어`란, `컴퓨터에게 수행할 작업을 지시하는 것`
  - 

명령형 vs 선언형

명령형 - 절차적, 객체지향
선언형(`무엇을`, 어떻게는 추상화 ) - 논리형, 함수형

모르겠다 시발~

여튼, 객체지향은 프로그래밍을 '객체들의 집합'. 함수형은 '함수'들의 집합.   
다시 말하면, `객체 vs 함수`. 포ㅇ인트는 속성값을 저장할 수 있다는 것.아닐까.   
이로 인해 상속을 한다던가. 반면 함수는 기능만 가져다 쓰거나 조합할 뿐.   
그래서 유지보수나 이해하기에는 객체가 더 나을 수 있지만, 효율이나 사이드 이펙트 면에서는 함수가 더 나을 ..

HTML, CSS, JS 등으로 구성된 웹 페이지는, 웹서비스라는 결과물을 얻기위해 웹 브라우저라는 계산기에 들어가는 입력값.ㄷ

## js란? (다소 깊은 내용들 keyword)

- 파볼만한 것 : 1page
  > 프로토타입 / 다중 패러다임 / 단일 스레드 / 동적 언어 / 객체지향형   
  > 덩적 기능 : 런타임 객체 구성, 변수 매개변수 목록, 함수 변수, 동적 스크립트 생성, 객체 검사, 소스코드 복구.미ㅏㅡㄴ네ㅐㅏ래ㅔㅏㅎㅋ
## API (어떻게 보면, 스크립트 언어로서 정체성)
  - 브라우저 api (DOM API, Geolocation API, Canvas, WebGL, WebRTC)
  - 서드파티 api ()

## 역할 (js가 하는 일)
### 웹 페이지를 로드할 때 발생하는 일.
- 브라우저 실행환경(브라우저 탭)에서 코드(html, css, js)실행 
- js는 dom api를 통해 html과 css를 동적으로 수정.(수정하려는 html,css보다 js먼저 불러오면 오류가 발생 )

## 브라우저 보안
- 탭끼리는 독립적 > 물론 이것도 방법이 있긴하다네 ㄷㄷ

## 실행순서
## 인터프리터와 컴파일러
  - js는 인터프리터이지만, JIT컴파일.(바로바로 번역되는)

## js 연결 방법.
  - 내부 (`script`요소 안에 직접 코드를 치는 것.)
  - 외부 (`script`요소 src 속성 사용 +@ defer 고려.)
  - 인라인 (특정 html요소 안에 onclick속성 안에 함수를 넣는 것.)
    -> 비추, addEventListener (유지보수 측면에서)

## 스크립트 로딩 전략
  - defer, async : 외부 스크립트 연결시 브라우저가 페이지 로딩과 스크립트로딩(별도 스레드에서)을 동시에
    - async가 지정된 스크립트는 다운로드 즉시 실행. 현재 페이지의 렌더링 중단되며, 순서 보장x
    - defer는 모든 컨텐츠를 다 불러온 이후 실행.
  - addEventListener('DOMContentLoaded', ()=>{})
  - script요소 바디 태그 맨 마지막
    - => 그러나 HTML로딩 전에 스크립트 로딩과 분석역시 x
    - => 대형 사이트는 로딩 속도 문제가 있을 수 있음.
----------

 - 스코프 : 변수와 함수가 접근 가능한 범위.

# JS 하나씩 정리 
## 문법과 자료형 : 기본 문법 / 변수 선언 / 자료형 및 리터럴
### 변수 : 값의 컨테이너 ('식별자'는 변수명)
  - 선언 : var / let / const
   - 전역 / 로컬 / 로컬
   - 호이스팅, 즉 끌고 올라와지는건 셋다 동일한데, 초기화 문제(undefined vs TDZ) 

### 문자열 : '', "", ``
  - ``(템플릿 리터럴) : js삽입가능, 여러줄 가능
  - 문자열 연산자 : +
  - 문자열 메서드(객체시잖어~, 유사배열객체) : length, indexOf(), slice, replace, 대소문자.

### 조건문 : if, switch, 삼항
### 반복문 : 참이면 종료 / 종료조건
  - for, while
  - break, continue
### 함수 : 메서드, 함수, 익명함수
### 프로토타입 : 생성자 함수의 속성. / new 는 생성자 함수의 호출.
클래스의 방식은 엄격하게 상위에서 하위로 상속되는 개념이라면, 프로토타입은 prototype 속성과 __proto__를 사용해서 자유롭게 연결될 수 있다는 게 클래스와 프로토타입의 가장 큰 차이점 
  - 함수.call(this, [...Arg])
  - Object.creat()

### JSON으로 작업하기.
  - json mime : application/json
  - json은 순수하게 데이터 포멧 : 즉, 메서드는 담을 수 있음.
  - json은 프로퍼티도 ""로, (''은 사용x)
  - JSON.stirngfy() / JSON.parse()
  - json을 가져오기 위해서는 XMLHttpRequest api.

### 비동기 - 단일 스레드 - 런타임 환경 : promise, fetch, async
  - HTTP 요청 만들기(fetch), 카메라 또는 마이크에 엑세스(getUserMedia), 파일 선택하도록 요청(showOpenFilePicker), 그외 이벤트, 웹 API
  - 개념 :  장기 실행 작업 시작 >> 시작 후 즉시 반환되고, 콜백함수로 다른 이벤트 응답 가능하도록 >> 메인 스레드를 차단하지 않는 방식으로 작업 실행 >> 작업이 끝나면 결과 알려주기.
  - 일반적인 방법은 콜백함수의 활용이지만, 오류처리하기가 힘듦 >> Promise
  - Promise는 비동기 프로그래밍의 기초.
    - "비동기 작업의 결과값"을 나타내는 개체. new Promise()
    - Promise는 작업의 상태를 나타냄 : pending, fulfill,reject
    - then 메소드 : 인수(콜백함수)를 2개받음(1개는 생략가능). 이행시, 실패시.
    - catch 메소드 : 해당 행위에 대한 즉각적인 오류 처리에는 then에서 해도 되지만, 그렇지 않은 경우, catch
    - all 메소드 : 모든 작업이 완료되면 이행. ( cf, any())
      ex) promise.all([fetch1, fetch2, fetch3]).then((responses)=>{})

    >> 종합하면, Promise객체는, 비동기 작업의 3가지 상태에 대한 객체이고, 각 상태에 따라 처리하는 콜백함수를 받아 작업을 완료 및 반환. 또한 해당 객체에 then/catch 메서드가 있음.

 ## 클라측 웹 API (브라우저 API, 서드파티 API)
  - JS, API 및 기타 JS도구 간의 관계
    - 브라우저/서드파티/라이브러리(JQuery)/프레임워크(라이브러리와의 차이점은 "제어 반전")

  - 일반적인 브라우저 API
    - DOM
    - fetch
    - 그래픽 그리기 및 조작 (Canvas, WebGL)
    - 오디오 및 비디오 재생 (HTMLMediaElement)
    - 기기 하드웨어와의 상호작용 (Geolocation)
    - 클라이언트 측 저장소 API (Web Storage, IndexedDB)
      - 가장 초기 형태 : 쿠키 (물론, 세션 ID 및 엑세스 토큰 같은 사용자 개인화 및 상태와 관련된 데이터를 저장하는데는 여전히)
      - 
  
  - 서드파티 API
    - 일반적으로 API키가 필요.


  - API 작동 : 객체를 사용하여 API와 상호작용.
    - 인식 가능한 진입점 (DOM - document)
    - 추가 보안 메커니즘.

